# Memory Management

One of the main responsibility of kernel is to manage memory: processes should not interfere with each other's memory (unless by design e.g. IPC) + protect kernel memory

Memory model:
- Flat memory model: logical memory = physical memory
- Segmentation
- Paging

## Paging Theory

Logical memory is divided into a number of fixed size blocks known as pages
Physical memory is divided into blocks of the same size known as page frames

Page table: data structure which maps pages and page frame

Memory Management Unit (MMU) -> responsible for memory address translation

Provides memory protection -> since all accesses is seen by the kernel

## Virtual Memory

Aside from protection, memory management -> utilize as much CPU as possible

Main problem -> program takes up memory space but lie idle (esp. true for big software, not everything is developed)

Virtual memory!

Demand paging -> only load starter code, load only wen needed, swap when useless

Page replacement algorithm: FIFO, LRU, etc.

Page table can store metadata e.g. if page is present in memory or is in disk

Page fault: exception that memory of process is not loaded, need to load


## Paging in x86

paging is not available by default on real mode, can only be used in 32-bit environment (unlike segmentation)

How to enable paging?

Go to protected mode, enably by changing control register CR0 of x86 last bit from 0 to 1

Types of paging?

There are 2 more bits to change paging mode:
- first one is PAE bit (fifth bit of CR4) -> 1 PEA enabled 0 PEA disabled
- second bit is LME in a register called IA32_EFER -> 1 switch fro protected mode 32 bit to long wode 64 bit, when PAE bit is 1 then 4-level mode is enabled

(in 64 bit architecture, paging is available for both protected and long mode)

In 32 bit, there are 2 available sizes for a page: 4KB and 4MB + 4GB memory is addressable in this mode

### Structure of Linear Memory Address

32 bits: 
- [22, 31]: Page Group Entry -> Page Group Address (1024 page groups)
- [12, 21]: Page Table Entry -> Page address (1024 pages)
- [0, 11]: Offset

Any memory address generated by executing code is logical address -> need to be translated to get the real address

First step: use segment descriptor to translate a logical address to a linear address by using the mechanism we have mentioned

When paging is disabled, the resulted linear address will be the physical (real) address that can be sent to the main memory to get the required data

When paging is enabled, the linear address needs further translation to obtain physical address -> page table is required

Multi-level Paging -> save memory -> only need to load the needed parts of page table instead of whole page table into the memory

### Page Directory

Can hold up to 1024 entries -> each entry points to a page table and each one can hold up to 1024 entries

How to find page directory? 
- use register CR3 which stores the base physical memory address of current page directory
- first part of a linear address is an offset within the page directory, when an addition operation is performed between the first part of a linear address and the value on CR3, the result will be the base memory address of the entry that represents a page table table that contains an entry which represents the page that contains the required data

### Page Directory Entry
- 4 Bytes
- represent the physical memory address of the page table this entry represents
- not all page tables that a page directory points to should be loaded into the main memory -> only the needed page tables, the rest are stored in secondary storage until they are needed
- we need some place to store a flag that tells us whether the page table in question is laoded into the main memory -> the job of bit 0: 1 present 0 need to load

Protection Scheme:
- Bit 1 in page directory entry -> 0: read only 1: writable
- Bit 2: 0: only privilege level 0, 1, 2 can access 1: PL 3 can access

Caching:
- Cache hit, cache miss
- In memory -> use TLB 
- Bit 4 of page directory entry: 1: no caching 0: caching (why disable caching? testing, debugging, some software faster w/o caching)
- write policy -> if cache has change how to save it to memory/ disk: 1. write-through -> write in both cache and source 2. write0back -> only on cache and save later on 

More configurations
- Bit 3 decides writing policy: 1: write through 0: write back
- Bit 5 access bits: 1 -> processor set value 1 when page table is accessed 0 -> set 0 is responsibility of kernel
- Bit 7: 0 -> page size 4KB 1 -> page size 4MB

### Page Table

In 4KB page environment, page table is referred to by an entry in the page directory

Each page table -> hold 1024 entries

Find base page table address -> add page table entry -> get base memory address -> add offset -> get memory address

Entry of page table -> exactly the same as entry of page directory, its size is 4 bytes

Some diff:
- Bit 7: ignored (used to decide page size in page directory)
- Bit 6: dirty bit (ignored in page directory) -> indicate we need to change, this is old entry -> because we don't delete old entry just set dirty bit to 1 (1: is dirty 0: is not dirty)

## Implementing Memory Management

Basics:
We need memory managemetn so we can allocate memory dynammically

Paging:
- valid page directory should be initialized, its address should be loaded in the register CR3
- paging should be enabled by modfying the value of CR0 -> tell processor to start using paging and translate linear address (instead of interpreting linear address as physical address)
- We need to implement paging for each process, but here we only implement paging for kernel